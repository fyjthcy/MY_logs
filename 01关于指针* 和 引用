const 限定一个对象为只读属性。 
先从一级指针说起吧： 
（1）const char p    限定变量p为只读。这样如p=2这样的赋值操作就是错误的。 
（2）const char *p   p为一个指向char类型的指针，const只限定p指向的对象为只读。这样，p=&a或  p++等操作都是合法的，但如*p=4这样的操作就错了，因为企图改写这个已经被限定为只读属性的对象。 
（3）char *const p  限定此指针为只读，这样p=&a或  p++等操作都是不合法的。而*p=3这样的操作合法，因为并没有限定其最终对象为只读。 
（4）const char *const p 两者皆限定为只读，不能改写。 
有了以上的对比，再来看二级指针问题： 
（1）const char **p  p为一个指向指针的指针，const限定其最终对象为只读，显然这最终对象也是为char类型的变量。故像**p=3这样的赋值是错误的，而像*p=？ p++这样的操作合法。 
（2）const char * const *p 限定最终对象和 p指向的指针为只读。这样 *p=?的操作也是错的。 
（3）const char * const * const p 全部限定为只读，都不可以改写。
 
指针的好处：
1.动态分配内存。
2.可以多个相似变量的一般访问。
3.为动态数据结构，尤其是树和链表，提供支持。
4.便利数组，解析字符串。
5.作为函数参数时候，可以按照引用传递函数参数，提高开发效率。

指针与引用的区别：
1. 指针存放地址，逻辑上独立，可被改变，志向的地址也可改变， 引用只是一个别名，逻辑上不独立。
2. 引用使用时不需要解引用（*），指针需要解引用。
3. 指针只被初始化一次，之后不能改变，从一而终。
4. 引用不能为空，指针可以。
5. sizeof对引用是对引用的对象，对指针用，则是对指针本身。
6. 指针和引用++意义不同。
7. 返回动态分配的对象和内存，必须用指针，引用可能引起内存泄漏。

